
How to integrate this chatbot framework with different platforms:

1. WhatsApp Integration (using Twilio):
```python
from twilio.rest import Client
from flask import Flask, request

class WhatsAppIntegration:
    def __init__(self, chatbot_app):
        self.chatbot = chatbot_app
        self.client = Client(os.getenv("TWILIO_ACCOUNT_SID"), 
                           os.getenv("TWILIO_AUTH_TOKEN"))
        
    def handle_message(self, incoming_msg):
        response = self.chatbot.get_response(incoming_msg, "Chitti Boy")
        return self.client.messages.create(
            from_=f"whatsapp:{os.getenv('TWILIO_PHONE_NUMBER')}",
            body=response,
            to=f"whatsapp:{incoming_msg.from_}"
        )

app = Flask(__name__)
chatbot = ChatbotApp()
whatsapp_handler = WhatsAppIntegration(chatbot)

@app.route("/webhook", methods=["POST"])
def webhook():
    incoming_msg = request.values.get('Body', '')
    whatsapp_handler.handle_message(incoming_msg)
    return "OK", 200
```

2. REST API Integration (for No-Code Platforms):
```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

class ChatRequest(BaseModel):
    message: str
    bot_name: str = "Chitti Boy"

app = FastAPI()
chatbot = ChatbotApp()

@app.post("/chat")
async def chat_endpoint(request: ChatRequest):
    try:
        response = chatbot.get_response(request.message, request.bot_name)
        return {"response": response}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/train")
async def train_endpoint(data: dict):
    try:
        if "text" in data:
            chatbot.process_scraped_data([data["text"]])
        return {"status": "success"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

3. Webhook Integration (for Zapier/Make):
```python
class WebhookHandler:
    def __init__(self, chatbot_app):
        self.chatbot = chatbot_app
        
    def process_webhook(self, data):
        if "message" not in data:
            return {"error": "No message provided"}
            
        response = self.chatbot.get_response(
            data["message"], 
            data.get("bot_name", "Chitti Boy")
        )
        
        return {
            "response": response,
            "timestamp": datetime.now().isoformat()
        }

@app.post("/webhook/zapier")
async def zapier_webhook(data: dict):
    handler = WebhookHandler(chatbot)
    return handler.process_webhook(data)
```

4. Embed Code Generator for Websites:
```python
def generate_embed_code(bot_id, domain):
    return f"""
    <div id="chatbot-container"></div>
    <script>
        window.chatbotConfig = {{
            botId: "{bot_id}",
            apiEndpoint: "https://{domain}/chat",
            containerSelector: "#chatbot-container"
        }};
    </script>
    <script src="https://{domain}/static/chatbot.js"></script>
    """

@app.get("/embed/{bot_id}")
async def get_embed_code(bot_id: str):
    domain = os.getenv("DOMAIN_NAME")
    return {"embed_code": generate_embed_code(bot_id, domain)}
```

5. Mobile App Integration:
```python
@app.post("/api/mobile/chat")
async def mobile_chat_endpoint(request: dict):
    try:
        response = chatbot.get_response(
            request["message"],
            request.get("bot_name", "Chitti Boy")
        )
        
        if request.get("voice_response", False):
            audio_file = chatbot.text_to_speech(response)
            return {
                "text_response": response,
                "audio_url": audio_file
            }
        return {"response": response}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

Implementation Notes:
- Add necessary environment variables in `.env`
- Install required dependencies (`twilio`, `fastapi`, `flask`)
- Set up proper security measures (API keys, rate limiting)
- Implement error handling and logging
- Add CORS settings for web integrations
- Consider implementing caching for better performance
- Add authentication for sensitive endpoints
- Implement rate limiting for API endpoints

The framework can be integrated with most platforms by exposing appropriate API endpoints and implementing platform-specific handlers.
